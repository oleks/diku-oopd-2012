\section{Assignments}

It has been observed that computer science students often do not gain a
thorough understanding of the ``human readable'' aspect of code production
until a rather late stage in their education\footnote{Cite 3-rd year
students.}. Some do not even gain such an understanding before receiving a BSc
degree\footnote{Cite StatML problems.}.

Usually, this understanding is established in connection with having to deal
with other people's code, e.g. reviewing or extending it. This is not an
inherent part of the current BSc degree in computer science, and is a practice
commonly left to students with part-time middle-class programming jobs,
teachers' assistants, and instructors\footnote{Cite interviews with
instructors and students with past programming jobs.}.

As a result, it would seem that many students will either go on with their
professional careers, programming in such a way that other programmers would
rather rewrite their code than understand it, or have to reconsider their
coding style when they enter the professional environment\footnote{Cite
interviews with businesses.}.

This is not so surprising when we consider that ``solving programming problems
in such a way that accounts for usability and readability of the solution'' is
not explicitly stated in the formal BSc degree
description\cite{studieordning-2009}. Although this description does name some
adjacent topics such as human-computer interaction, ability document one's
programs, as well as communicate in oral or written form about programming
concepts, it would seem that these topics circle around this problem, but never
mention it explicitly.

It would seem that most educators and professional programmers would agree --
good programmers have a moral sense of responsibility to document their code,
not least make it readable to other human beings, so long as use by other human
beings is intended (which it often is). It is to mitigate this lack of
appreciation of human-to-human interaction inherent in the programming
practise, that an alternative assignment strategy is suggested.

The current assignment strategy in the course is a series of weekly take-home
programming assignments. These assignments are individual, and graded by TAs
immediately after the submission deadline. The TAs provide formative feedback
as well as a grade of either 1(best), 0.5, or 0(worst). If the student does not
initially get a full score, the student has a chance to resubmit the assignment
within a few days hereafter. In order to be eligible for the exam, the student
must e.g. accumulate a sum of 4 points out of a series of 6 such weekly
assignments.

This method has a series of drawbacks in and of itself. In particular, it can
be challenging for the TAs to grade the submissions in due time and with
quality feedback. Partial automation of the correction process is also
generally out of question since at this stage, students are still often unable
to follow explicit textual specifications, such as names of functions.

An alternative strategy, taking into account the requirement of human
readability, could be the following:

\begin{enumerate}

\item Devise a consecutively related series of weekly assignments, such
that every consecutive assignment builds upon a solution to the previous one.

\item Devise a mechanism for shuffling submissions, such that as a part of a
consecutive assignment, students receive a solution to the previous assignment
done by one of their peers, chosen at random.

\end{enumerate}

The first point is not much of a concern in the context of Object-Oriented
Programming.  Indeed, one of the formal course goals is to teach modular,
step-wise development of medium-sized programs\footnote{Cite OOPD description}.
This has also been successfully practised in the past\footnote{Cite OOPD from
before 2010.}.

The second point requires much elaboration.

First off, the shuffling should anonymizing, such that the random peers cannot
(trivially) be personally identified by students. This might not necessarily be
the case in a medium-sized programming business, but it can be said to be the
case in large companies as well as large open-source projects, where the peers
are often geographically and temporally scattered. The intent is to decrease
blaming strategies, and to promote adaptive and tolerant strategies for
programming.

