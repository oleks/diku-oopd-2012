\chapter{Generics}

Sometimes subtype polymorphism doesn't quite cut it. This is best illustrated
by an example. Consider building an \mono{AggregateCollection}, capable of
collecting any type of object. Let the collection have the following methods:

\begin{codebox}
\Procname{\mono{uint AggregateCollection::Length()}}
\end{codebox}

\begin{codebox}
\Procname{\code{void AggregateCollection::Append(T value)}}
\zi Appends the \mono{value} at the end of the collection.
\zi \kw{before} $\textt{\kw{this}.length} = n$
\zi \kw{after} $\left\{
\begin{array}{l}
\textt{\kw{this}.length} = n + 1\\
\textt{\kw{this}.Get(n)} = \textt{value}
\end{array}
\right.$
\end{codebox}

\begin{codebox}
\Procname{\mono{T AggregateCollection::Get(uint index)}}
\end{codebox}

Here the type \code{T} is used as a placeholder, and is not a built-in or
declared type.  The question is -- what type should we put in place of
\code{T}? Our requirement was that the collection can collect any type of
object that we can instantiate in our system. We know that there is a supertype
to all reference types in our system, namely \code{Object}, and that our system
has subtype polymorphism.  Shouldn't we then simply use \code{Object} in place
of \code{T}?

This has the major pitfall that all \code{Object}'s that we append to the
collection are merely \code{Object}'s when we get them again, i.e. precious
type information is lost. Hence, programmers have to resort to meagre
conventions. For instance, all \code{AggregateCollection}s of \code{String}s
get the prefix \code{StringCollection}. If all programmers follow this
convention, then it is safe to explicitly cast the \code{Object} that we get
from an \code{AggregateCollection} prefixed with \code{StringCollection} to the
appropriate subtype, i.e. \mono{String}.

Naturally, this is notoriously error prone. Note, how this is case of the
common to computer science problem of the lack of semantics in the programming
language to ensure formality.

The immediate alternative is to copy and paste this code for every type that we
might wish to collect, thereby declaring a collection type for each collected
type.  This is both notoriously error prone and notoriously
boring\footnote{Especially given the fact the number of such types is countably
infinite.}. Surely there must be a way to automate this process, and sure
enough, we figured it out back in the
1970's\cite{the-c++-programming-language}. The technique is formally called
\key{parametric polymorphism}, but has the generally accepted popular names of
\key{template programming} and \key{generic programming}.

Object-oriented languages generally posses a special type of parametric
polymorphism. In particular, the parameters limit only the supertype of the
possible objects, and there are means to limit the types of parameters with
various constraints, for instance, that they implement some sequence of
interfaces.

\newpage


The requirement of generics is akin to so many other problems in computer
science, where the type system is extended to ensure that certain logical
errors are be avoided at runtime.

Wrt. structured programming -- it is not an extension of the type system -- it
is an extension of the language semantics with the intent to ensure that
certain logical errors (that arise with the use of say goto statements) are
avoided at runtime. Hence, this behaviour is observed not only in type system
extensions, but elsewhere as well.
