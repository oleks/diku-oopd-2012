%\section{The von Neumann architecture}

An alternative programming paradigm, the \key{imperative}, is historically
closer to hardware. It emerged as the programming paradigm for computer
architectures stemming from John von Neumann's original proposal for the design
of the digital computer\cite{von-neumann}.  A key aspect of the von Neumann
architecture is that it keeps the computer rather feebleminded, leaving it to
the programmer to be the clever one. Inevitably, no good introduction to the
imperative programming paradigm can commence, without at least a gentle
introduction to the von Neumann architecture.

\begin{definition}

A \key{computer}\footnotemark is an entity with \key{state} and
\key{processors}. A processor performs \key{actions} that change the state of
the computer.

\footnotetext{Although at the beginning of the 20th century, a ``computer'' was
still a profession, today most computers are electronic machines.  We'll use
the words ``computer'' and ``machine'' interchangably.}

\end{definition}

While it may be modern (about time) to speak of computers as machines with
multiple processors, we will restrain ourselves to single processor machines.
Programming for multiple processors raises a range of problematics irrelevant
to the core matter of these lecture notes. At times it will provide for an
interesting discussion to consider how certain aspects map over into
multiprocessor machines, but in such cases they will be mentioned explicitly.

\begin{definition}

``An action is a happening, taking place in a finite period of time and
establishing a well-defined, intended \key{net-effect}.''
\cite{dijkstra-introduction}

\end{definition}

This definition highlights two important points. Firstly, an action takes place
in a finite period of time, say $T_1$. This allows for us to speak of the
points in time $T_n$ and $T_{n+1}$, as the times of action inception and
termination, i.e. $T_{n+1}=T_n+T_1$. Secondly, an action establishes a
well-defined, intended net-effect. This highlights that we are interested in
actions that do something, indeed something expected.

To this end, it makes sense to describe the ``net-effect'' of an action as the
difference between the state of the computer at time $T_n$ and $T_{n+1}$.
However, this notion breaks down as we turn to multiprocessor machines, where
the clear benefit of performing multiple actions at once has been utilized. So
apply this notion with care.

% ``action â€“ a function or a function object that mutates the value of an
% object'' -- Alexander Stepanov, Adobe notes.

As an example of an action, consider doing the laundry. Given a pile of dirty
laundry, the net-effect of this action is the same pile of laundry, but clean.
Clearly, the functional paradigm fits abnormally to this type of problem.
Knitting a pile of clean laundry, same but different, is not nearly as
practical as cleaning the dirty pile. Indeed, why should we dispose of a pile
of perfectly good clothing, just because it has gotten a little dirty? The
process of cleaning, rather than knitting, is explicit to the programmer in the
imperative paradigm.

While modifying global state, rather than producing new values, is a marvel of
imperative programming, it is important that we achieve \emph{exactly} the
intended net-effect; nothing more, nothing less. So while we wish to change the
state of the world in a particular way, we also wish to avoid
\key{side-effects}, so as to avoid a general butterfly effect, where doing the
laundry for instance, causes a hurricane on the other side of the world. We
attempt achieve this ``safety'' by grouping the elements in the world into
well-defined and well-kept \key{data structures}.

\begin{definition}

A data structure is a particular ordering of data elements with well-defined
methods for managing the data structure, such that the ordering is maintained.

\end{definition}

We say that a set of data structures defining the same ordering on the same
types of data elements, and providing the same methods of manipulation, belong
to the same \key{class} of data structures. A class of data structures is a
type of data element. This notion is intentionally recursive.

It is clear that designing a new piece of hardware for every type of action is
impractical. The desired net-effect can often be achieved through a series of
basic actions. For instance, the sum of $n$ different numbers can be computed
using $n-1$ binary additions. Hence, we can make due with a \key{sequencing
mechanism} and good old binary addition, rather than design a new piece of
hardware for every conceivable $n$.

A computer, therefore, has a finite set of basic actions, called its
\key{instruction set}. A computer program is specified in terms of a sequence
of these basic actions, called a \key{program text}. The computer executes the
program by performing the sequence of actions in order.

The sequence of basic actions is not a sequencing mechanism in and of itself.
Indeed, we are unable to specify a computer program for summing a sequence of
an arbitrary size $n$, since no sequence of binary additions will ever be
enough for every conceivable $n$.  What's more, why duplicate the actions?
Afterall, as we sequentially sum a sequence of numbers we're doing the same
action, a binary addition, just on different data.

To mitigate this lack of flexibility, the von Neuman architecture introduces
the \key{jump} action. Since the program is specified as a finite sequence
of basic actions, we can easily assign a unique integer index to every action in the sequence.
As the computer is performing an action at a particular index at any point in time


The
idea is then to let the computer have an action that allows to specify an arbitrary action as
the next action to perform, rather then the one then immediately next
instruction.

At this point it makes sense to reconsider the concept of time. The convention is to let all basic
actions be upper bounded by some constant value. This allows us to analyze the
running time of computer programs in terms of how much sequencing is going on.


At any point in time, the computer is performing some particular action, 

and provide a
mechanism for performing a sequence of actions in order. This however, still does not allow us to write a 

Indeed, depending on our level of interest, we may consider an action as either
a basic, non-divisible happening, or as a sequence of subactions necessary to
achieve the overall net-effect. The sub-actions themselves may be considered in
terms of their sub-sub-actions, and so on. Indeed, one possible program design
method is to start with a high-level overview and to gradually dig into the
details.  Naturally, such a hierarchical ordering of a program also facilitates
the human comprehension of the program. This calls to attention a quote by
Donald Knuth\cite{knuth-review-of-sp}:

\begin{quote}"You have perhaps had a dream much like mine: Wouldn't it be nice
to have a glorious system of complete maps of the world, whereby one could (by
turning dials) increase or decrease the scale at will? A similar thing can be
achieved for programs, rather easily, when we give the programs a hierarchic
structure like those constructed step-wise. It is not hard to imagine a
computing system which displays a program in such a way that, by pressing
an-appropriate button, one can replace the name of a routine by its expansion
on the next level, or conversely."\end{quote}

Here the word ``routine'' stands for an action, and ``its expansion on the next
level'' is the sequence of sub-actions necessary to achive the intended
net-effect. The choice of the word ``routine'' is not an unlucky one. Afterall,
we all have some sort of routine for doing the laundry, and doing the laundry
is a rather routine task! Let us now consider the immediate expansion of doing
the laundry, assuming that we have a common washing machine at our disposal:

\begin{codebox}
\li Split the pile into colors and whites.
\li Wash colors.
\li Wash whites.
\li Pile up colors and whites in a clean pile.
\li Return the clean pile.
\end{codebox}

We all know that whites and colors don't mix well in a washing machine. Indeed,
a higher temperature should be used for whites, since they are generally harder
to get clean, and a lower temperature should be used for colors, since high
temperatures may leed to color bleeding.

A common mistake is to oversee a colored piece in a pile of whites, and wash
the pile under a high temperature.  Most likely, this will lead to all whites
in that pile bleeding from white to a light shade of the mixed-in color. That
definitely leads to a hurricane on the other side of the world!  As such, this
is a \key{pre-} and \key{postcondition} pair we forgot to mention. Not only
should the pile be clean, but every piece of laundry should also keep its
original color.

\begin{definition}

Assuming that preconditions hold before the action commences, the
postconditions should hold after the action terminates.

\end{definition}

We say ``should'', becuase there is currently no automatic way of being certain
of this for an arbitrary action in by far the most practical programming
languages. Hence, it is often up to the programmer to manually prove that the
postconditions will hold.

We now state the pre- and postconditions of doing the laundry:

\begin{codebox}
\zi
$\begin{array}{ll}
&\text{Given a dirty pile, a clean pile is returned.}\\
\wedge&\text{Every piece of laundry keeps its original color.}
\end{array}$
\end{codebox}

Here, the symbol $\wedge$ means ``and'', i.e. both statements should hold.

When \key{declaring} an action, we also specify its name, as well input and
output parameters. So a complete declaration of doing the laundry looks like
this:

\begin{codebox}
\Procname{$\proc{Do-The-Laundry}::(Laundry)\rightarrow Laundry$}
\zi
$\begin{array}{ll}
&\text{Given a dirty pile, a clean pile is returned.}\\
\wedge&\text{Every piece of laundry keeps its original color.}
\end{array}$
\end{codebox}



as well as the pre- and postconditions. When \key{defining}
an action, we specify its actual sequence of subactions. We make this
distinction because an action declaration may well have several definitions.

Of course, at some point, some real work has to get done.

A von-Neuman computer has a basic set of actions that it can perform.


The initial pile of dirty laundry is not a particularly interesting data
structure, but it will prove beneficial to morph this data structure into other
types as we \emph{progress} through the action. Indeed, 

Of course, at some point we must reach basic, non-divisible 


 i.e.  doing
the laundry, or as a sequence of subactions. This sequence represents the steps
necessary to achieve the overall intended net-effect.


(Naur,
function vs. process).

\begin{codebox}
\Procname{$\proc{Do-The-Laundry}\p{dirtyPile}$}
\li \Return $cleanPile$
\end{codebox}

We can dissect this definition into
\key{pre-conditions} and \key{post-conditions}, and state their relationship in
terms of an \key{implication}, denoted by the symbol $\Rightarrow$:

\begin{equation}
\text{Dirty pile}\Rightarrow \text{Clean pile}.
\end{equation}



More formally, if at time $T_n$ we
have a pile of dirty laundry, and perform an action in the subsequent time slot
$T_1$, then at time $T_{n+1}$ we have a pile of clean laundry.


To define the
net-effect of an action, we state the conditions that must hold at time
$T_{n+1}$, given that certain conditions hold at time $T_n$. We call these
conditions the \key{post-} and \key{pre-conditions}, respectively. Given an
action $a$, we say that if the preconditions hold, then after the action, the
post-conditions must hold, denoted

\begin{equation}
\text{Precondition} \Rightarrow^a \text{Postcondition}.
\end{equation}


The effect
of the action is that a precondition \emph{implies} a post condition, we denote
this with the symbol $\Rightarrow$.

It does not make sense to do the laundry without a pile of dirty laundry, and a
good ``doing the laundry'' action leaves all the laundry clean after the action
took place. We therefore state the following:

 Before the action
commences, you have a pile of dirty laundry; after the action, the laundry is
clean. We call these the \key{pre-} and \key{postconditions} of an action,
respectively. In particular, it does not make sense to do the laundry unless
you have a pile of dirty laundry, and the post-condition that the laundry is
clean is probably useful for future actions.

The post-conditions are not complete. There are certain things that we would
like to do to facilitate further actions. For instance, it is useful if in the
process of doing the laundry we didn't mix clean and dirty laundry, and at best
-- neatly stacked the clean laundry in the closet.


The post-conditions are not
completely well-formed however. In particular, 

where whites are mixed with
colors. Anyone who's ever done their laundry knows that it's no good to mix 

After the action, the clothes should be neatly stacked in the closet. 

% doing the laundry 
