%\section{Functional programming}

What you've been practising thus far, is mostly the \key{functional}
programming paradigm.

\begin{definition}

Functional programming treats computation as application of mathematical
functions to \key{immutable} data.

\end{definition}

Programming using the functional paradigm is done by \key{defining}
mathematical functions. The execution of a program is then the application of
some particular \key{entry function} to some, if any, program arguments.
Functions themselves are defined in terms of applications of other functions,
and branching depending on the outcome of these applications.  Naturally, some
functions are basic, i.e. implemented in hardware, and they are the ones doing
actual work. You can think of this as a complicated corporate structure where
every non-basic function is a manager.

A mathematical function defines a relation between a set of possible inputs,
its \key{domain}, and a set of possible outputs, its \key{codomain}. For a
function to be well-defined, every value in its domain of must have a
\key{unique representation}, as must every value in its codomain.
A function can then \key{consume} a representation of a value in its domain,
and \key{produce} a representation of a corresponding value in its codomain.

% Domain and codomain representations do not have to unique wrt. to one
% another.

Due to this pattern of consumption and production of representations, we say
that all data is immutable, i.e. there's no notion of one representation being
mutated into another. Mutation however, is useful in practise. It is not
unlikely that the output of a function can have a representation very close to
the representation of its input. In such cases, mutation can save us a great
deal of trouble when preparing a value to output.

Functional programming languages usually hide this aspect from the programmer,
lettting the language itself worry about such ``premature'' matters. Hence,
when programming in a functional programming language, we're less concerned
with the flow of data throughout the program, and more concerned with the
mappings that our functions define.
