\section{Functional programming}

What you've been practising thus far, is mostly the \key{functional}
programming paradigm.

\begin{definition}

In a purely functional programming paradigm, values are \key{immutable}, and
programming is done by describing the relationships between values using
\key{functions}.

\end{definition}

Less formally, in pure declarative programming, we avoid describing the
\key{flow} of the program and resort to pure function application, or rather,
function application is the only program connective we've got.  In this
paradigm, the programmer is concerned with the \key{mapping} of input values to
output values, such that the mapping defines a \key{class of computations} that
the program can evoke.  The programmer is less concerned with being
particularly clear about the flow of control or data throughout the program, as
this is superimposed by the mapping.

As you may have already noticed, this paradigm can be notoriously difficult to
apply to certain problems, despite (or due to) it's neat mathematical
properties.  What's more, the accurate student would've already noticed that
you've not done \emph{pure} declarative programming, but rather, already have
experience with a few \key{control flow structures} such as \key{if-} and
\key{case-} \key{statements}\marginExercise{cfsahof}.  Why this is, will become
apparent shortly. We will return to these, and many more control flow
structures, in a bit as well.
