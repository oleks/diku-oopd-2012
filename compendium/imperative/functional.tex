%\section{Functional programming}

What you've been practising thus far, is mostly the \key{functional}
programming paradigm.

\begin{definition}

Functional programming treats computation as application of mathematical
functions to \key{immutable} data.

\end{definition}

Programming using the functional paradigm is done by \key{defining}
mathematical functions. The execution of a program is then the application of
some particular \key{entry function} to some, if any, program arguments.
Functions are commonly defined in terms of applications of basic, and
program-defined functions, as well as branching depending on the outputs of
these functions.

A mathematical function defines a relation between a set of possible inputs,
its \key{domain}, and a set of possible outputs, its \key{codomain}. For a
function to be well-defined, every value in its domain of must have a
\key{unique representation}, as must every value in its codomain\footnotemark.
A function can then \key{consume} a representation of a value in its domain,
and \key{produce} a representation of a corresponding value in its codomain.

\footnotetext{Domain and codomain representations do not have to unique
wrt. to one another.}

Due to this pattern of consumption and production of representations, we say
that all data is immutable, i.e. there's no notion of one representation being
mutated into another. Mutation however, may be useful in practise. It is not
unlikely that the output of a function can have a representation very close to
the representation of its input. In such cases, mutation can save us a great
deal of trouble when constructing the output value. For instance, appending a
value to a list, yields the original list with just one more value appended to
it.

Functional programming languages usually hide this aspect from the programmer,
lettting the language itself worry about such ``premature'' matters. Hence,
when programming in a functional programming language, we're less concerned
with the flow of data throughout the program, and more concerned with the
mappings that our functions define.
