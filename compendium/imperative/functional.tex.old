What you've been practising thus far, is mostly the \key{functional}
programming paradigm.

\begin{definition}

Functional programming treats computation as application of mathematical
functions to \key{immutable} data.

\end{definition}

Programming using the functional paradigm is done by \key{defining}
mathematical functions. The execution of a program is then the application of
some particular \key{entry function} to some, if any, program arguments.
Functions themselves are defined in terms of function application and branching
of execution depending on the outcomes of boolean predicates.

A mathematical function defines a relation between a set of possible inputs,
its \key{domain}, and a set of possible outputs, its \key{codomain}. For a
function to be well-defined, every value in its domain of must have a
\emph{unique} \key{representation}, as must every value in its codomain.  A
function can then \key{consume} a representation of a value in its domain, and
\key{produce} a representation of a corresponding value in its codomain.

% Domain and codomain representations do not have to unique wrt. to one
% another.

Due to this pattern of consumption and production, we say that all data is
immutable, i.e. there's no notion of one representation being mutated into
another. Mutation however, is useful in practise. It is not unlikely that the
output of a function has a representation very close to the representation of
its input. In such cases, mutation can save us a great deal of trouble when
preparing a value to output.

Functional programming languages usually hide this aspect from the programmer,
letting the language itself worry about such ``premature'' matters. We say that
in a functional paradigm we're less concerned with the flow of data throughout
our program, and more concerned with the mappings that our functions define.
