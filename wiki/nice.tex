\chapter{Imperative programming}

Consider doing the laundry. If we have a common, house-hold washing machine at
our disposal; the \emph{routine} may look something like this:

\begin{enumerate}

\item Split the laundry into whites and colours.

\item Wash whites.

\item Wash colours.

\item Dry the laundry.

\item Neatly pile up the laundry.

\end{enumerate}

In a conventional functional programming language, e.g. SML, this may end up
looking something like this:

\begin{code}
(pile (dry (wash (split laundry))))
\end{code}

While comprehensible, this does not read very well; in particular, it reads
backwards. Most \wikipedia{Indo-european}{Indo-European} languages read
left-to-right, top-to-bottom. Here, the flow of the program is expressed
right-to-left, and there is no notion of top-down descent at all. If anything,
there could've been a notion of bottom-up ascent, if we had, for instance,
layed out the program like this:

\begin{code}
(pile
  (dry
    (wash
      (split laundry))))
\end{code}

This reads like we're putting the cart before the horse. Indeed, some tasks,
such as doing the laundry, cooking a meal, writing a program, are inherently
sequential. Functional programming languages may often be
\explanation{syntactically}{A programming language has syntactic rules defining
the valid positioning of symbols. In this case, the syntactic rule is that the
name precedes the arguments in a function call.} unfit for writing programs for
such tasks.

We will develop the notion of a \emph{well-written program} throughout these
lecture notes. However, we begin with the following definition:

\begin{definition}
A well-written program is a well-read program.
\end{definition}

That is, a well-written program is comprihensible to another programmer.


We've arguably cheated a bit when we showed you the procedure first, and the
functional implementation last. Let's try doing it the other way around:
